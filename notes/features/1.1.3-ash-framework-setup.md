# Feature: Ash Framework Setup (Section 1.1.3)

## Summary
Set up comprehensive Ash framework infrastructure for the game server, including domains, resources, real-time features, and API layer foundation to provide declarative domain modeling for game entities.

## Requirements
- [ ] Configure Ash application with PostgreSQL data layer
- [ ] Create base resource module with common patterns
- [ ] Set up domain structure for game entities
- [ ] Configure real-time features with PubSub notifications
- [ ] Create API layer foundation (REST/GraphQL ready)
- [ ] Implement audit fields and soft delete support
- [ ] Add authorization policies structure
- [ ] Create migration strategy using Ash tooling

## Research Summary
### Existing Usage Rules Checked
- Ash usage rules: Use domains and resources, code interfaces preferred, business logic in actions
- Resource organization: Domain-centric structure, avoid direct Ash calls in web modules
- Code interfaces: Define on domains, use get_by for primary key lookups

### Documentation Reviewed
- Ash 3.5.33: Declarative framework with domains and resources as core concepts
- AshPostgres: PostgreSQL data layer with migration support
- Ash.Notifier.PubSub: Real-time notifications via Phoenix.PubSub
- Resource configuration: Attributes, actions, relationships, data layer
- Domain structure: Groups related resources with boundaries

### Existing Patterns Found
- lib/ash_game_server/repo.ex: AshPostgres.Repo already configured
- config/config.exs: Basic Ash configuration present
- Phoenix.PubSub: Already configured in application

### Technical Approach
1. **Domain Structure**: Create hierarchical domains (Core, Players, World, Combat)
2. **Base Resource**: Shared module with common attributes and callbacks
3. **Real-time Integration**: Ash.Notifier.PubSub with existing Phoenix.PubSub
4. **Data Layer**: Leverage existing AshPostgres.Repo configuration
5. **Code Interfaces**: Define on domains for clean API boundaries
6. **Migration Strategy**: Use Ash codegen for database migrations

## Risks & Mitigations
| Risk | Impact | Mitigation |
|------|--------|------------|
| Domain boundary violations | High | Clear separation of concerns, documented boundaries |
| Migration conflicts | Medium | Use Ash migration tools, version control migrations |
| Performance with real-time | Medium | Selective broadcasting, efficient queries |
| Authorization complexity | High | Start simple, incrementally add policies |

## Implementation Checklist
- [ ] Configure Ash in config files
- [ ] Create base resource module with common patterns
- [ ] Set up GameCore domain with base entities
- [ ] Create Players domain with player resources
- [ ] Create World domain for game world entities
- [ ] Add PubSub notifier configuration to resources
- [ ] Implement soft delete concern module
- [ ] Add audit fields concern module
- [ ] Create code interfaces on domains
- [ ] Set up migration generation commands
- [ ] Create example Player resource
- [ ] Create example GameSession resource
- [ ] Add basic authorization policies
- [ ] Test resource CRUD operations
- [ ] Verify PubSub notifications work

## Questions for Pascal
1. Should we implement GraphQL API now or focus on REST initially?
2. What authorization strategy do you prefer - policies or manual checks?
3. Should player data be in separate domain or part of GameCore?
4. Do you want full audit trail or just created/updated tracking?

## Log
- Created feature branch: feature/1.1.3-ash-framework-setup
- Starting Ash configuration