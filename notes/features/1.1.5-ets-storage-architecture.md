# Feature: ETS Storage Architecture (Section 1.1.5)

## Overview
Implement high-performance ETS-based storage for ECS components, providing ultra-fast in-memory data access with optional persistence bridge to Ash resources.

## Goals
- Sub-millisecond component access times
- Support for 1000+ concurrent entities
- Efficient memory usage and cleanup
- Bridge to persistent storage via Ash
- Hot backup and recovery capabilities

## Technical Requirements

### 1. Table Structure Design
- Component-specific ETS tables
- Entity-to-component mapping tables
- System query optimization tables
- Metadata and statistics tables

### 2. Storage Patterns
- Entity ID as primary key
- Component data as tuples/maps
- Indexing for fast queries
- Memory-efficient serialization

### 3. Access Layer
- High-level component API
- Batch operation support
- Query optimization
- Transaction-like operations

### 4. Persistence Bridge
- Sync with Ash resources
- Incremental updates
- Snapshot generation
- Recovery mechanisms

### 5. Performance Monitoring
- Access statistics
- Memory usage tracking
- Query performance metrics
- Optimization recommendations

## Implementation Plan

### Phase 1: Table Management
1. Create ETS table supervisor
2. Implement table lifecycle management
3. Add table ownership patterns
4. Create backup mechanisms

### Phase 2: Component Storage
1. Design component table schema
2. Implement CRUD operations
3. Add batch operations
4. Create query optimization

### Phase 3: Entity Management
1. Create entity registry
2. Implement component composition
3. Add archetype instantiation
4. Create entity lifecycle hooks

### Phase 4: Persistence Integration
1. Bridge to Ash resources
2. Implement sync strategies
3. Add conflict resolution
4. Create recovery tools

### Phase 5: Performance & Monitoring
1. Add performance metrics
2. Implement memory monitoring
3. Create optimization tools
4. Add profiling capabilities

## Technical Design

### Table Structure
```elixir
# Component Tables - one per component type
:position_components -> {entity_id, %{x: float, y: float, z: float}}
:health_components -> {entity_id, %{current: int, max: int}}

# Entity Registry
:entities -> {entity_id, %{archetype: atom, components: [atom], metadata: map}}

# System Queries - cached query results
:system_queries -> {system_name, [entity_id]}

# Statistics
:table_stats -> {table_name, %{size: int, access_count: int, last_updated: datetime}}
```

### Access Patterns
```elixir
# Single component access
ECS.Storage.get_component(entity_id, :position)

# Bulk component access
ECS.Storage.get_components(entity_id, [:position, :velocity])

# System queries
ECS.Storage.query_entities([:position, :velocity])

# Batch operations
ECS.Storage.update_components([{entity_id, :position, data}])
```

### Integration Points
- **ECS DSL**: Component definitions drive table creation
- **Jido Agents**: Agents access components via storage layer
- **Ash Resources**: Persistence bridge for durability
- **Phoenix PubSub**: Change notifications

## Benefits
1. **Performance**: Ultra-fast memory access
2. **Scalability**: Efficient for large entity counts
3. **Flexibility**: Dynamic component composition
4. **Reliability**: Backup and recovery
5. **Monitoring**: Performance insights

## Risks & Mitigations
- **Risk**: Memory exhaustion with large worlds
  - **Mitigation**: Pagination and cleanup strategies
- **Risk**: Data loss on crashes
  - **Mitigation**: Periodic snapshots to persistent storage
- **Risk**: Concurrent access issues
  - **Mitigation**: Proper ETS access patterns and ownership

## Success Criteria
- [ ] Component access under 1ms
- [ ] Support 10,000+ entities
- [ ] Memory usage under 1GB for typical game
- [ ] Successful recovery from snapshots
- [ ] Performance metrics available

## Dependencies
- ETS (built-in Erlang)
- Ash Framework (for persistence)
- Spark DSL (for component definitions)
- Phoenix.PubSub (for notifications)

## Timeline
- Phase 1: 2 hours - Table management
- Phase 2: 3 hours - Component storage
- Phase 3: 2 hours - Entity management
- Phase 4: 2 hours - Persistence bridge
- Phase 5: 1 hour - Performance monitoring

Total estimated time: 10 hours